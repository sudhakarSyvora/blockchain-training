{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ERC20Token/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ERC20Token is IERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    address private _contractOwner;\n    address private _ERC721ContractAddress;\n\n    constructor(\n        uint256 totalSupplyValue,\n        string memory nameValue,\n        uint8 decimalsValue,\n        string memory symbolValue\n    ) {\n        _totalSupply = totalSupplyValue;\n        _balances[msg.sender] = totalSupplyValue;\n        name = nameValue;\n        decimals = decimalsValue;\n        symbol = symbolValue;\n        _contractOwner = msg.sender;\n    }\n\n    function setERC721ContractAddress(address _erc721ContractAddress) external {\n        require(_contractOwner == msg.sender);\n        _ERC721ContractAddress = _erc721ContractAddress;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return _balances[_owner];\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    ) external returns (bool success) {\n        require(\n            _balances[msg.sender] >= _value && _to != address(0),\n            \"ERC20: Insufficient balance\"\n        );\n        _balances[msg.sender] = _balances[msg.sender] - _value;\n        _balances[_to] = _balances[_to] + _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success) {\n        require(\n            _from != address(0) &&\n                _to != address(0) &&\n                _allowed[_from][msg.sender] >= _value &&\n                _balances[_from] >= _value,\n            \"Not approved\"\n        );\n        _allowed[_from][msg.sender] -= _value;\n        _balances[_to] += _value;\n        _balances[_from] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    ) external returns (bool success) {\n        require(_spender != address(0));\n        _allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256 remaining) {\n        require(_owner != address(0) && _spender != address(0));\n        return _allowed[_owner][_spender];\n    }\n\n    function mint(address _to, uint256 _value) external returns (bool success) {\n        require(msg.sender == _contractOwner, \"Owner can only mint new tokens\");\n        _totalSupply = _totalSupply + _value;\n        _balances[_to] = _balances[_to] + _value;\n        return true;\n    }\n\n    function transferForNFT(address _tokenOwner,address _buyer, uint _value) external {\n        require(\n            msg.sender == _ERC721ContractAddress,\n            \"Not called by authorised contract!\"\n        );\n        _balances[_tokenOwner] += _value;\n        _balances[_buyer] -= _value;\n    }\n}\n"
    },
    "contracts/ERC721Token/ERC721Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n \nimport \"../ERC20Token/ERC20Token.sol\";\n\n \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n \n\n// Your ERC20Token contract\n contract ERC721 is IERC721 {\n\n    // Mapping from token ID to owner address\n    mapping(uint => address) internal _ownerOf;\n\n    // Mapping owner address to token count\n    mapping(address => uint) internal _balanceOf;\n\n    // Mapping from token ID to approved address\n    mapping(uint => address) internal _approvals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    //Mapping from tokenid to prices\n    mapping(uint => uint) public _price;\n\n    //Mapping to check wether price has been set or not\n\n    mapping(uint=>bool)  internal _isPriceSet; \n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function ownerOf(uint id) external view returns (address owner) {\n        owner = _ownerOf[id];\n        require(owner != address(0), \"token doesn't exist\");\n    }\n\n    function balanceOf(address owner) external view returns (uint) {\n        require(owner != address(0), \"owner = zero address\");\n        return _balanceOf[owner];\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function approve(address spender, uint id) external {\n        address owner = _ownerOf[id];\n        require(\n            msg.sender == owner,\n            \"not authorized\"\n        );\n\n        _approvals[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function getApproved(uint id) external view returns (address) {\n        require(_ownerOf[id] != address(0), \"token doesn't exist\");\n        return _approvals[id];\n    }\n\n    function _isApprovedOrOwner(\n        address owner,\n        address spender,\n        uint id\n    ) internal view returns (bool) {\n        return (spender == owner ||\n            isApprovedForAll[owner][spender] ||\n            spender == _approvals[id]);\n    }\n\n    function transferFrom(address from, address to, uint id) public {\n        require(from == _ownerOf[id], \"from != owner\");\n        require(to != address(0), \"transfer to zero address\");\n\n        require(_isApprovedOrOwner(from, msg.sender, id), \"not authorized\");\n\n        _balanceOf[from]--;\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        delete _approvals[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint id) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint id,\n        bytes calldata data\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                IERC721Receiver.onERC721Received.selector,\n            \"unsafe recipient\"\n        );\n    }\n\n    function _mint(address to, uint id) internal {\n        require(to != address(0), \"mint to zero address\");\n        require(_ownerOf[id] == address(0), \"already minted\");\n\n        _balanceOf[to]++;\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint id) internal {\n        address owner = _ownerOf[id];\n        require(owner != address(0), \"not minted\");\n\n        _balanceOf[owner] -= 1;\n\n        delete _ownerOf[id];\n        delete _approvals[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n}\n\ncontract MyNFT is ERC721 {\n    ERC20Token public erc20Token;\n\n    constructor(address _ERC20TokenAddress) {\n        require(\n            _ERC20TokenAddress != address(0),\n            \"Invalid ERC20 token address\"\n        );\n        erc20Token = ERC20Token(_ERC20TokenAddress);\n    }\n\n    function mint(address to, uint id) external {\n        _mint(to, id);\n    }\n\n      function setPrice(uint256 id, uint256 value) external {\n        require(_ownerOf[id] == msg.sender, \"Only the owner can set the price\");\n        _price[id] =  value;\n        _isPriceSet[id]=true;\n    }\n\n    function exchange(uint id) external {\n        address tokenOwner = _ownerOf[id];\n        address buyer = msg.sender;\n        require(tokenOwner != address(0));\n        require(_isPriceSet[id], \"Price for the NFT is not set\");\n        uint buyerBalance = erc20Token.balanceOf(buyer);\n        require(buyerBalance >= _price[id]);\n        //Transfer tokens from owner's balance\n        erc20Token.transferForNFT(tokenOwner, buyer, _price[id]);\n        _balanceOf[tokenOwner]--;\n        _balanceOf[buyer]++;\n        _ownerOf[id] = buyer;\n        delete _approvals[id];\n        emit Transfer(tokenOwner, buyer, id);\n    }\n\n    function burn(uint id) external {\n        require(msg.sender == _ownerOf[id], \"not owner\");\n        _burn(id);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}